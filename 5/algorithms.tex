\section{Алгоритмы поиска выпуклой оболочки}

\subsection[title]{Алгоритм Джарвиса (заворачивание подарка)\footnote{Описан даже в Кормене}}
Самый естественный алгоритм, просто ищет последовательные вершины выпуклой оболочки, выполняя $h - 1$ шаг, 
на каждом из которых, по текущей вершине выпуклой оболочки выбирается подходящий кандидат на звание 
следующей вершины перебором множества $S$. На первом шаге в качестве текущей вершины используется самая левая точка $S$,
которая по утверждению (\ref{MostLeft}) принадлежит $CH(S)$. 

Время работы --- $O(n h)$.

\subsection[title]{Метод сканирования Грэхэма\footnote{Есть где угодно (Wikipedia)}}
\begin{statement}
Для вершин замкнутой $n$-звенной ломаной без самопересечений выпуклая оболочка может быть найдена за $O(n)$.
\end{statement}

Cуществует несколько способов генерации по множеству $S$ входа для метода сканирования Грэхэма.
\begin{itemize}
\item Сортировка точек из $S$ по полярному углу относительно некоторой точки гарантированно лежащий внутри $CH(S)$. 
  Этот способ используется в одном из вариантов \textit{MergeHull}.
\item Сортировка точек из $S$ по полярному углу (в данном случае можно по повороту!) относительно некоторой вершины $CH(S)$. 
  Это клаcсический алгоритм Грэхэма.
\item Склейка двух цепей, каждую из который можно получить сортировкой по полярному углу относительно 
  бесконечно удаленной точки. Скажем, для генерации первой цепи используем (0, 1, 0), для второй --- (0, -1, 0).
  Это алгоритм Эндрюса.
\end{itemize}

\subsection[title]{MergeHull\footnote{Можно почитать у О'Рурка}}
Применение стандартной идеи ``разделяй и властвуй'', а именно, разбиение $S$ на подмножества $S_1, S_2$, 
$S_1 \cup S_2 = S$, $S_1~\cap~S_2~=~\emptyset$, $||S_1| - |S_2||~\le~1$; построение $CH(S_1), CH(S_2)$; и слияние 
выпуклых оболочек. Различают варианты когда $S_1, S_2$ выбираются произвольным образом, 
и когда $S_1, S_2$ разделены в пространстве ($CH(S_1), CH(S_2)$ соотвественно тоже). Время работы обоих вариантов 
$O(n \log n)$.

\subsection[title]{QuickHull\footnote{Есть в Wikipedia}}
В среднем самый быстрый, хотя в худшем случае время работы может достигать $O(n^2)$. 
Также использует идею ``разделяй и властвуй''.

\subsection[title]{Алгоритм Чена}
Ассимптотическое время работы достигает нижней границы --- $O(n \log h)$, но на практике этот алгоритм не применим.

\subsection[title]{Инкрементальный алгоритм\footnote{Можно почитать у Препараты, Шеймоса}}